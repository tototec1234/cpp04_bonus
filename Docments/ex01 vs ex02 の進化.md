# CPP04: ex01 vs ex02 の進化

## 概要比較

| 項目 | **ex01 (I don't want to set the world on fire)** | **ex02 (Abstract class)** |
|------|--------------------------------------------------|---------------------------|
| **主要テーマ** | Brainクラス導入 + メモリ管理 | 抽象クラス化による設計の完成 |
| **学習目標** | 深いコピー、リソース管理、virtual destructor | 抽象クラス、pure virtual function |
| **Animalクラス** | 具象クラス（インスタンス化可能） | 抽象クラス（インスタンス化不可） |

---

## 技術的進化の詳細

### 1. クラス設計の進化

| 側面 | **ex01** | **ex02** |
|------|----------|----------|
| **Animal::makeSound()** | `virtual void makeSound() const;` | `virtual void makeSound() const = 0;` |
| **クラスの性質** | 具象クラス | 抽象クラス（Abstract class） |
| **インスタンス化** | `Animal animal;` ✅ 可能 | `Animal animal;` ❌ コンパイルエラー |
| **new による生成** | `new Animal();` ✅ 可能 | `new Animal();` ❌ コンパイルエラー |

### 2. 設計思想の進化

| 観点 | **ex01** | **ex02** |
|------|----------|----------|
| **設計哲学** | 「動物は具体的な記憶（Brain）を持つ」 | 「動物は抽象概念、具体的な種類のみ実在」 |
| **エラー防止** | 実行時の論理エラーに依存 | コンパイル時エラーによる強制 |
| **意図の明確化** | 実装レベルでの制約 | 言語機能による制約 |
| **保守性** | 開発者の注意に依存 | コンパイラによる自動チェック |

### 3. 機能継承と拡張

| 機能 | **ex01** | **ex02** |
|------|----------|----------|
| **Brain クラス** | ✅ 新規導入 | ✅ 継承 |
| **Deep Copy** | ✅ 新規実装 | ✅ 継承 |
| **メモリ管理** | ✅ new/delete対応 | ✅ 継承 |
| **Virtual Destructor** | ✅ 重要性を実証 | ✅ 継承 |
| **抽象クラス** | ❌ 未実装 | ✅ **新規追加** |
| **Pure Virtual Function** | ❌ 未使用 | ✅ **新規導入** |

---

## 実用性の比較

### 4. 実行時の動作

| シナリオ | **ex01** | **ex02** |
|----------|----------|----------|
| **Dog/Cat生成** | ✅ 正常動作 | ✅ 正常動作（同じ） |
| **多態性** | ✅ 正常動作 | ✅ 正常動作（同じ） |
| **Animal直接生成** | ⚠️ 可能だが無意味 | ❌ コンパイル時エラー |
| **Animal配列** | ✅ Dog/Cat混在可能 | ✅ Dog/Cat混在可能（同じ） |

### 5. エラー防止機能

| エラータイプ | **ex01** | **ex02** |
|-------------|----------|----------|
| **意味のないAnimal生成** | 実行時まで検出されない | コンパイル時に防止 |
| **makeSound()未実装** | 実行時にAnimalの音 | コンパイル時エラー |
| **設計意図の違反** | 論理的な制約のみ | 言語レベルの制約 |

---

## 課題書の要求と対応

### 6. 課題書での指示

| 要求事項 | **ex01** | **ex02** |
|----------|----------|----------|
| **「Creating Animal objects doesn't make sense after all」** | ❌ まだ作成可能 | ✅ **完全に解決** |
| **「It's true, they make no sound!」** | ⚠️ 実装依存 | ✅ 強制的に解決 |
| **「To avoid any possible mistakes」** | 開発者の注意に依存 | ✅ **自動防止** |
| **「Everything should work as before」** | - | ✅ 多態性は維持 |

### 7. 学習段階の進化

| 段階 | **ex01で学習** | **ex02で学習** |
|------|---------------|---------------|
| **基礎** | virtual destructor、Brain管理 | pure virtual function |
| **応用** | deep copy、メモリ管理 | abstract class設計 |
| **設計** | リソース管理パターン | **インターフェース設計** |
| **実践** | 多態性の実装 | **契約による設計** |

---

## コード例での比較

### 8. 問題となるコード

```cpp
// ex01では問題なくコンパイル・実行される
Animal* meta = new Animal();  // ✅ 可能（でも無意味）
meta->makeSound();            // ⚠️ "Animal makes a sound!" など

// ex02では以下がコンパイルエラー
Animal* meta = new Animal();  // ❌ Error: cannot instantiate abstract class
Animal animal;                // ❌ Error: variable type 'Animal' is an abstract class
```

### 9. 保証される動作

```cpp
// 両方で正常動作
Animal* dog = new Dog();      // ✅ 両方で可能
Animal* cat = new Cat();      // ✅ 両方で可能
dog->makeSound();            // ✅ 両方で "Woof!"
cat->makeSound();            // ✅ 両方で "Meow!"

// しかし ex02では確実に派生クラスの音のみ
// ex01では誤ってAnimalを作成する可能性があった
```

---

## 進化の意義

### 10. 設計原則の実現

| 原則 | **ex01** | **ex02** |
|------|----------|----------|
| **Open/Closed Principle** | 拡張可能、修正リスクあり | ✅ 拡張可能、修正に閉じている |
| **Liskov Substitution** | ✅ 実現 | ✅ より強固に実現 |
| **Interface Segregation** | 部分的 | ✅ **完全実現** |
| **Dependency Inversion** | 部分的 | ✅ **完全実現** |

### 11. 実世界での応用

| 用途 | **ex01レベル** | **ex02レベル** |
|------|---------------|---------------|
| **ゲーム開発** | キャラクター基底クラス | **抽象キャラクタークラス** |
| **GUI開発** | ウィジェット基底クラス | **抽象ウィジェットクラス** |
| **データベース** | レコード基底クラス | **抽象エンティティクラス** |

---

## まとめ: ex01 → ex02 の進化的意義

### 12. 核心的な変化

| 項目 | **変化の内容** |
|------|-------------|
| **パラダイム** | 「継承による実装」→「**契約による設計**」 |
| **安全性** | 「実行時検証」→「**コンパイル時保証**」 |
| **表現力** | 「実装レベル」→「**言語レベル**」 |
| **保守性** | 「開発者依存」→「**システム強制**」 |

**ex02は ex01の全機能を維持しながら、言語機能を活用してより安全で表現力豊かな設計を実現した完成形**

---

## 学習者への示唆

ex01→ex02の進化は、単なる技術的改良ではなく、**「実装思考」から「設計思考」への転換**を示している。

- **ex01**: 「正しく動く」コードの実装
- **ex02**: 「間違いを許さない」設計の実現

これは現代的なソフトウェア設計における「**契約による設計**」「**型安全性**」の基礎概念に直結する。
