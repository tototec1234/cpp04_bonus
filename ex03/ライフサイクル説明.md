# Ice/Cure ライフサイクル説明資料

## 実際の実行出力ログ（この説明で使用する実験例）

**注意**: 実行ごとにメモリアドレスは変化しますが、この説明では以下の特定の実行例を使用します。

```
AMateria parameterized constructor called this: 0x1366060e0
Ice default constructor called           this: 0x1366060e0
Ice copy constructor called              this: 0x136605fc0
Ice destructor called                   this: 0x1366060e0
AMateria destructor called                this: 0x1366060e0
AMateria parameterized constructor called this: 0x1366060e0
Cure default constructor called           this: 0x1366060e0
Cure copy constructor called              this: 0x136605fe0
Cure destructor called                   this: 0x1366060e0
AMateria destructor called                this: 0x1366060e0
Ice copy constructor called              this: 0x1366060e0
Cure copy constructor called              this: 0x136605d40
* shoots an ice bolt at bob *
* heals bob's wounds *
Ice destructor called                   this: 0x1366060e0
AMateria destructor called                this: 0x1366060e0
Cure destructor called                   this: 0x136605d40
AMateria destructor called                this: 0x136605d40
Ice destructor called                   this: 0x136605fc0
AMateria destructor called                this: 0x136605fc0
Cure destructor called                   this: 0x136605fe0
AMateria destructor called                this: 0x136605fe0
```

---

## 出力の流れと各ステップの説明

### プログラムの実行順序（main.cpp に基づく）

```cpp
1. IMateriaSource* src = new MateriaSource();
2. src->learnMateria(new Ice());     // ← ステップ1: Iceオブジェクトの学習
3. src->learnMateria(new Cure());    // ← ステップ2: Cureオブジェクトの学習
4. ICharacter* me = new Character("me");
5. tmp = src->createMateria("ice");  // ← ステップ3: Iceオブジェクトの生成
6. me->equip(tmp);
7. tmp = src->createMateria("cure"); // ← ステップ4: Cureオブジェクトの生成
8. me->equip(tmp);
9. ICharacter* bob = new Character("bob");
10. me->use(0, *bob);                // ← ステップ5: Ice使用
11. me->use(1, *bob);                // ← ステップ6: Cure使用
12. delete bob;
13. delete me;                       // ← ステップ7: Character削除（インベントリー内のMateriaも削除）
14. delete src;                      // ← ステップ8: MateriaSource削除（学習したMateriaも削除）
```

---

## 出力の詳細分析

### ステップ1: `src->learnMateria(new Ice())` の処理

```
AMateria parameterized constructor called this: 0x1366060e0
Ice default constructor called           this: 0x1366060e0
Ice copy constructor called              this: 0x136605fc0
Ice destructor called                   this: 0x1366060e0
AMateria destructor called                this: 0x1366060e0
```

**説明：**
1. `new Ice()` で新しいIceオブジェクトが作成される（アドレス: 0x1366060e0）
   - まず基底クラス`AMateria`のコンストラクタが呼ばれる
   - 次に`Ice`のコンストラクタが呼ばれる
2. `learnMateria()`内で`m->clone()`が呼ばれ、コピーが作成される（アドレス: 0x136605fc0）
3. 元のオブジェクト（0x1366060e0）は`delete m`で削除される
4. **結果**: MateriaSourceはコピーされたIceオブジェクト（0x136605fc0）を保持

**実装ファイル**: `learnMateria()` は `MateriaSource.cpp`、`clone()` は `Ice.cpp`

---

### ステップ2: `src->learnMateria(new Cure())` の処理

```
AMateria parameterized constructor called this: 0x1366060e0
Cure default constructor called           this: 0x1366060e0
Cure copy constructor called              this: 0x136605fe0
Cure destructor called                   this: 0x1366060e0
AMateria destructor called                this: 0x1366060e0
```

**説明：**
1. `new Cure()` で新しいCureオブジェクトが作成される（アドレス: 0x1366060e0）
   - **注意**: 前回削除されたメモリ領域が再利用されているため、同じアドレス（0x1366060e0）が使われている
   - これは**正常な動作**です（メモリアロケータの最適化）
2. `learnMateria()`内で`m->clone()`が呼ばれ、コピーが作成される（アドレス: 0x136605fe0）
3. 元のオブジェクト（0x1366060e0）は`delete m`で削除される
4. **結果**: MateriaSourceはコピーされたCureオブジェクト（0x136605fe0）を保持

**実装ファイル**: `learnMateria()` は `MateriaSource.cpp`、`clone()` は `Cure.cpp`

---

### ステップ3: `tmp = src->createMateria("ice")` の処理

```
Ice copy constructor called              this: 0x1366060e0
```

**説明：**
1. MateriaSource内のIceオブジェクト（0x136605fc0）に対して`clone()`が呼ばれる
2. 新しいIceオブジェクトが作成される（アドレス: 0x1366060e0）
   - **注意**: 再度、解放されたメモリ領域が再利用されているため、同じアドレスが使われている
   - これは**正常な動作**です（メモリアロケータの最適化）
3. **結果**: `tmp`は新しいIceオブジェクト（0x1366060e0）を指す

**実装ファイル**: `createMateria()` は `MateriaSource.cpp`、`clone()` は `Ice.cpp`

---

### ステップ4: `tmp = src->createMateria("cure")` の処理

```
Cure copy constructor called              this: 0x136605d40
```

**説明：**
1. MateriaSource内のCureオブジェクト（0x136605fe0）に対して`clone()`が呼ばれる
2. 新しいCureオブジェクトが作成される（アドレス: 0x136605d40）
3. **結果**: `tmp`は新しいCureオブジェクト（0x136605d40）を指す

**実装ファイル**: `createMateria()` は `MateriaSource.cpp`、`clone()` は `Cure.cpp`

---

### ステップ5-6: `me->use()` の実行

```
* shoots an ice bolt at bob *
* heals bob's wounds *
```

**説明：**
- Characterのインベントリー内のIce（0x1366060e0）とCure（0x136605d40）が使用される
- これらは正常に動作している

**実装ファイル**: `use()` は `Character.cpp`、実際の使用処理は `Ice.cpp` と `Cure.cpp` の `use()` 関数

---

### ステップ7: `delete me` の処理

```
Ice destructor called                   this: 0x1366060e0
AMateria destructor called                this: 0x1366060e0
Cure destructor called                   this: 0x136605d40
AMateria destructor called                this: 0x136605d40
```

**説明：**
1. Characterのデストラクタが呼ばれる
2. インベントリー内の各Materiaが削除される
   - Ice（0x1366060e0）が削除される
   - Cure（0x136605d40）が削除される

**実装ファイル**: Characterのデストラクタは `Character.cpp`

---

### ステップ8: `delete src` の処理

```
Ice destructor called                   this: 0x136605fc0
AMateria destructor called                this: 0x136605fc0
Cure destructor called                   this: 0x136605fe0
AMateria destructor called                this: 0x136605fe0
```

**説明：**
1. MateriaSourceのデストラクタが呼ばれる
2. 学習済みの各Materiaが削除される
   - Ice（0x136605fc0）が削除される（ステップ1で作成されたコピー）
   - Cure（0x136605fe0）が削除される（ステップ2で作成されたコピー）

**実装ファイル**: MateriaSourceのデストラクタは `MateriaSource.cpp`

---

## 重要なポイント：同じアドレスが再利用される理由

### なぜ同じアドレス（0x1366060e0）が複数回使われているのか？

**答え：メモリアロケータの最適化による正常な動作です。**

1. **メモリアロケータの仕組み**
   - `new`でメモリを確保し、`delete`で解放すると、そのメモリ領域は「再利用可能」になる
   - 次回`new`が呼ばれたとき、既に解放された領域を再利用することで効率化する
   - これは**標準的なC++の動作**であり、問題ではありません

2. **なぜ問題ないのか**
   - 各オブジェクトの**ライフサイクルが正しく管理**されている
   - オブジェクトが削除された**後**に同じアドレスが再利用されている
   - **使用中のメモリ領域が上書きされることはない**

3. **確認方法**
   - 各オブジェクトの作成と削除の順序が正しい
   - 同一アドレスが同時に複数のオブジェクトで使われていない
   - デストラクタが適切なタイミングで呼ばれている

---

## ライフサイクルのまとめ

### Iceオブジェクトのライフサイクル

1. **学習時（learnMateria）**
   - 作成 → コピー → 元の削除 → コピーを保持

2. **生成時（createMateria）**
   - 保持しているオブジェクトからクローン → 新しいオブジェクトを返す

3. **削除時**
   - 生成されたオブジェクトは使用後に削除
   - MateriaSource内のオブジェクトは最後に削除

### Cureオブジェクトのライフサイクル

Iceと同様のパターンで管理されている

---

## レビュー時の説明ポイント

1. **「同じアドレスが使われているように見えますが、問題ありません」**
   - メモリアロケータが解放済みメモリを再利用しているため
   - オブジェクトのライフサイクルは正しく管理されている

2. **「各オブジェクトは適切なタイミングで削除されています」**
   - 使用中のオブジェクトが誤って削除されることはない
   - メモリリークは発生していない

3. **「learnMateria と createMateria の設計が正しく動作しています」**
   - `learnMateria`: 渡されたオブジェクトをクローンして保持し、元を削除
   - `createMateria`: 保持しているオブジェクトからクローンを作成して返す
   - これにより、MateriaSourceは「テンプレート」として機能している

4. **「Deep Copy が正しく実装されています」**
   - 各コピー操作で新しいオブジェクトが作成されている
   - シャローコピーによる問題は発生していない
