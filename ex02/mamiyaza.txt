来るの遅くなってすみません。レビューお疲れさまでした。

 [mandatory] 曖昧な用語、概念があったので確認した
 polymorphism compile-time (static)
 Polymorphism ↕ runtime (dynamic)
 polymorphism ad-hoc poly
 morphism　：演算子のオーバーロード等
 
 
 CPP02 ↕ parametric polymorphism　：ジェネリクス（C++ではテンプレート）等
 CPP07 ↕ subtyping polymorphism (subtyping)　：同一の基底クラスから派生した複数の派生クラスを同一の型で扱うことができる機能。（他の言語では知らないがとりあえずC++では）具体的には、基底クラス型ポインタまたは参照で派生クラスのインスタンスを扱わせることで実現する。（↔基底クラス型オブジェクトで派生クラスを扱おうとした場合は単にslicingされる（派生クラス特有の情報が切り落とされ失われる＝基底クラスの情報のみがコピーされる）。）
 
 
 派生クラス独自の実装で上書きしたい関数があれば、基底クラスの関数宣言にvirtualキーワードをつける。
 内部的には、vtable（仮想関数テーブル）というシステムがプログラム実行時に（=動的に）管理してくれてるぽい（同じvirtualキーワードでもCPP03の仮想継承のほうとは無関係）。
 
 
 CPP04 仮想関数 純粋仮想関数 抽象クラス インターフェースクラス
  前回に比べ、 テストケースがカテゴリごとに分かりやすく分類されており、またループになっていて使いやすくなっていた ANSIエスケープコードをマクロにして専用ヘッダに置いていて、可読性が上がっていた .gitignoreを活用してもいいかも
   [ex00] 初期化リスト　順序は宣言順であることに注意 基底クラスの特定の関数が非virtualの場合に、当該関数を派生クラスでオーバーライドし、基底クラス型ポインタまたは参照で派生クラスのインスタンスを扱わせ当該関数を呼んだときに基底クラス側の実装が呼ばれることを確認した
   [ex01] テストについて、課題要件のcreate and fill an array of Animal objectsに従うとsubtype polymorphismを利用できなくなるため、基底クラス型オブジェクトではなく基底クラス型ポインタの配列を用いた 基底クラスのデストラクタが非virtualの場合に、基底クラス型ポインタまたは参照で派生クラスのインスタンスを扱わせ、deleteすると、基底クラスのデストラクタしか呼ばれず（派生クラスのデストラクタが呼ばれず）メモリリークが起きることを確認した
   
   [ex02] 抽象クラスをインスタンス化できないことを確認した レビューありがとうございました！
   